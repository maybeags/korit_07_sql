# 입실 체크 해주세요 !! 💌
# 복습
```sql
SELECT u.id, u.username, u.phone, o.id, od.product_id
  FROM users u 
    LEFT JOIN orders o 
    ON u.id = o.user_id
    INNER JOIN orderdetails od ON o.id = od.order_id
  ORDER BY u.id;
```
- FROM 내에서는 JOIN을 중첩해서 사용 가능. 이상의 경우에서는 첫 번째 JOIN의 ON 절 뒤에, 두 번째 JOIN을 작성했다고 볼 수 있습니다. 필요한 정보가 셋 이상의 테이블에 나뉘어 있어도, 키 값을 기반으로 연결할 수 있다면 한 번에 조회할 수 있습니다(근데 서브쿼리 배우면 대부분 서브쿼리 쓰겠다고 하다가 망하는 경우가 많습니다). 예제 쿼리는 LEFT (OUTER) JOIN을 통해 주문 정보가 없는 회원의 주문 정보를 포함했고, INNER JOIN을 통해 orders / orderdetails의 교집합 정보만을 출력했습니다.
  - 근데 확인해보니까 어차피 orders에 주문을 했어야 주문 세부 사항이 나오니까 LEFT JOIN을 썼어도 결과의 차이는 없었을 겁니다.

예제 : users와 orders를 하나로 결합하는데, 회원 정보가 없는 주문 정보도 출력할 수 있도록 작성하시오.
```sql
# 이건 주문 내역이 있는 회원만 출력되었습니다.
SELECT *
  FROM users u RIGHT JOIN orders o ON u.id = o.user_id
  ORDER BY u.id
  ;
# 주문 내역이 없는 회원도 출력하려면(RIGHT JOIN을 활용하여),
SELECT *
  FROM orders o RIGHT JOIN users u ON o.user_id = u.id
  ORDER BY u.id
  ;
```
이상의 경우에서는 차집합 개념을 들 수 있는데, 그렇다면 LEFT JOIN과 동일한 기능을 하는 것처럼 보입니다. 하지만 INNER JOIN과 결과값이 같죠(즉, 주문 내역이 없는 회원의 정보는 출력되지 않았음을 의미합니다). 

그래서 LEFT JOIN과 명확히 동일한 결과값을 만들기 위해서는 테이블 순서를 바꿀 필요가 있습니다.
  이상과 같은 이유로 많은 기업에서는 RIGHT JOIN 대신에 LEFT JOIN만 사용하도록 권장하는 편입니다. 먼저 나온 테이블이 기준이 되도록 해서 LEFT JOIN만 쓰든지, 아니면 교집합만 사용하기 위해 INNER JOIN을 쓴다고 보셔도 무방합니다.

예제 : user와 orders의 _모든 가능한 행 조합_ 을 만들어내는 SQL 쿼리를 작성하시오.
```sql
SELECT *
  FROM user u CROSS JOIN orders o
  ORDER BY u.id
  ;
```
- CROSS JOIN은 두 집합을 _조합_ 해 만들 수 있는 _카테시안 곱(cartesian product)_ 을 출력합니다. 순서는 u.id를 기준으로 작성해뒀습니다.
  모든 조합이 나오기 때문에 LEFT / RIGHT / INNER JOIN처럼 u.id = o.user_id 같은 조건 없이 두 테이블의 모든 행을 합쳐서 만들 수 있는 모든 경우의 수를 출력하는 겁니다. 그렇다면 10 개의 row를 지니는 테이블과 20 개의 row를 지니는 테이블을 CROSS JOIN하면 10 * 20 으로 200 개의 row를 지니는 행이 나오며, 이외의 경우의 수는 존재하지 않습니다.
  _모든_ 이 매우 중요합니다. _조건_ 없습니다.

이상을 이유로 실제 운영 환경에서는 CROSS JOIN을 제한하는 편입니다. 컴퓨터의 리소스를 너무 잡아먹는데다가 실질적으로는 쓸모가 거의 없어서입니다.

그리고 CROSS JOIN과 유사해보이기는 하지만 조금 다른 FULL OUTER JOIN이란 것도 있습니다.

FULL OUTER JOIN = LEFT JOIN + RIGHT JOIN - INNER JOIN

# JOIN 정리하기
- JOIN은 복수의 테이블을 하나로 결합할 때 사용. 여러 곳에 기록된(정규화된) 데이터를 마치 하나의 테이블처럼 합칠 때 필요.

형식 :
```sql
FROM
  테이블1 a (LEFT/INNER) JOIN 테이블2 b
  ON a.PK = b.FK;
```
JOIN은 FROM 절에서 수행됩니다. 그렇다면 _가장 먼저_ 실행된다고 볼 수 있습니다. JOIN 이후 나머지 WHERE, GROUP BY, HAVING, SELECT, ORDER BY가 실행되기 때문에 FROM 절에서 지정한 표의 별칭을 이후 제어문에서 전부 사용이 가능합니다.

또한 조건에서 볼 수 있듯이 _공통된 컬럼 값인 키 값_ 이 존재해야지만 JOIN으로 결합 할 수 있습니다. 키 값은 여러 개가 있을 수 있어, 어떤 값을 기준으로 할지 ON에서 명시합니다(저희 예제에서는 PK / FK가 하나씩입니다). 

JOIN 중첩하기
```sql
FROM 테이블1 a
  (LEFT / INNER) JOIN
  테이블2 b
  ON a.PK = b.FK          # 참고로 ON 뒤에 pk 쪽을 써주는게 또 뭐 관례라고 합니다
  (LEFT / INNER) JOIN
  테이블3 c
  ON 조건어쩌고 = c.FK;
```
- INNER JOIN : 각 테이블의 키 값이 일치하는 행만(교집합만) 출력함. 가장 기본적인 default JOIN이기 때문에 INNER 생략이 가능합니다. 그런데 가독성 문제로 명시적으로 INNER를 작성할 것을 권장합니다.

- LEFT (OUTER) JOIN : 왼쪽 테이블의 모든 데이터를 결과에 포함시켜서 출력.
- RIGHT (OUTER) JOIN : 오른쪽 테이블의 모든 데이터를 결과에 포함시켜서 출력.
- FULL OUTER JOIN : 좌우측 테이블의 모든 데이터를 결과에 포함시켜서 출력(CROSS와의 차이점에 유의할 것).

- CROSS JOIN
```sql
FROM
  테이블1 a CROSS JOIN 테이블2 b
```
근데 사실 CROSS 쓸거면 조건이 필요없으니까 테이블 별칭이 없어도 되지 않냐 싶을 수도 있는데, SELECT에서 필요한 컬럼만 뽑아낼 때 쓰기 때문에 조건이 없더라도 별칭은 정해주는 편입니다.

FULL OUTER JOIN은 조건에 부합할 때만 결과값을 만들어내지만 CROSS JOIN은 모든 경우의 수를 전체 출력합니다. 다릅니다. 달라요.

Chrome에서 해커랭크 검색 -> sql 시험 문제가 있는데, 우리나라에서는 카카오가 SQL 코테 문제를 여기서 출제하는걸로 알려져있습니다.

# 연습 문제
1. users와 staff를 참고하여 회원 중 직원인 사람의 회원 아이디, 이메일, 거주 도시, 거주 국가, 성, 이름을 한 화면에 출력하시오.
```sql
SELECT u.id, u.username, u.city, u.country, s.last_name, s.first_name
  FROM users u INNER JOIN staff s ON u.id = s.user_id
  ORDER BY u.id;
```
2. staff와 orders를 참고하여 직원 아이디가 3번, 5번인 직원의 담당 주문을 출력하시오(단 직원 아이디, 직원의 성, 주문 아이디, 주문 일자만 출력할 것).
```sql
SELECT s.id, s.last_name, o.id, o.order_date
FROM staff s LEFT JOIN orders o ON s.id = o.staff_id # INNER JOIN도 가능
WHERE s.id IN (3, 5)
ORDER BY s.id;
```
3. users와 orders를 참고하여 회원 국가별 주문 건수를 내림차순으로 출력하시오.
```sql
SELECT u.country, COUNT(DISTINCT o.id) AS orderCnt
  FROM users u INNER JOIN orders o
    ON u.id = o.user_id
  GROUP BY u.country
  ORDER BY orderCnt DESC;
```
4. orders와 orderdetails, products를 참고하여 회원 아이디 별 주문 금액의 총합을 정상 가격과 할인 가격 기준으로 각각 추출하시오. 단 정상 가격 주문 금액의 총합 기준으로 내림 차순하시오.
```sql
SELECT o.user_id
  , ROUND(SUM(p.price * od.quantity), 2) AS sumPrice
  , ROUND(SUM(p.discount_price * od.quantity), 2) AS sumDiscountPrice
  FROM
    orders o LEFT JOIN orderdetails od ON o.id = od.order_id
  INNER JOIN products p ON od.product_id = p.id
  GROUP BY o.user_id
  ORDER BY sumPrice DESC;
```
5. 다음 조건의 테이블이 있다고 가정합니다.
  - 왼쪽 테이블 A : 컬럼 개수 5 개 / 150행
  - 오른쪽 테이블 B : 컬럼 개수 7개 / 100행
  - 두 테이블은 공통 키 값 컬럼을 1 개 보유

  이상의 조건의 두 테이블을 CROSS / LEFT / RIGHT / INNER JOIN으로 결합했을 때 결과 테이블의 행과 열 개수를 계산하시오.
  각각 최소 / 최대를 기준으로 하시면 됩니다.

  1. CROSS JOIN 
    - rows : 150 * 100 = 15000
    - columns : 12개

  2. LEFT JOIN
    - rows : 최소 150행, 최대 15000행
    - columns : 12개

  3. RIGHT JOIN
    - rows : 최소 100행, 최대 15000행
    - columns : 12개

  4. INNER JOIN
    - rows : 최소 0행, 최 15000행
    - columns : 12개

# UNION
## 컬럼 목록이 같은 데이터를 위아래로 결합
- 데이터를 위아래로 수직 결합을 지원하는 UNION 은 컬럼의 형식과 개수가 같은 두 데이터 결과 집합을 하나로 합친다고 볼 수 있습니다.

- 조건을 설정해서 결합해야하는 JOIN과 달리, UNION은 컬럼의 형식 / 개수만 동일하면 어떻게든 결합이 가능합니다.

예시 : users를 full scan한 결과 집합해서 UNION 적용
```sql
(SELECT * FROM users)
UNION
(SELECT * FROM users);
```
이상의 쿼리를 실행해봤을 때 결과가 `SELECT * FROM users;`과 동일합니다.
_UNION_ 은 중복 제거 기능이 있습니다.

예시 : users를 full scan한 결과 집합해서 UNION 적용(중복 제거 수행 하지 않은 결과값 출력할 것)

```sql
(SELECT * FROM users)
UNION ALL           # 중복 제거를 수행하지 않도록 하는 키워드 ALL
(SELECT * FROM users);
ORDER BY id;
```
UNION의 기본 전제 : 컬럼의 형식 / 개수 -> SELECT 수행 이후에 커스텀한 컬럼에서도 동일하게 적용됩니다.

```sql
(SELECT * FROM users) UNION ALL (SELECT id, phone, country, city FROM users);  
```
그래서 이상의 쿼리문의 실행 결과는 오류가 발생하게 됩니다.
어제 학습해서 배웠던 SQL문의 적용 순서에 관한 복습이 요구됩니다.

결과적으로 SELECT 문이 수행된 이후의 결과값을 기준으로 UNION이 실행되겠죠(소괄호가 적용된 부분이 먼저 수행되기도 하니까). 그렇다면 각각의 소괄호1, 2의 연산 결과는 서로 다른 컬럼의 개수를 지니게 되기 때문에 UNION ALL 연산이 불가능해진다는 결과를 얻게 됩니다.

연습 : users에서 country가 Korea인 회원 정보만 추출하고, Mexico인 회원 정보만 추출하여 결합하시오. 컬럼은 id, phone, city, country만 출력하고, 최종 결과 집합은 country 기준 알파벳 순으로 정렬할 것.
```sql
SELECT id, phone, city, country FROM users WHERE country IN ('Korea', 'Mexico') ORDER BY country;
```
UNION ALL 적용 예시
```sql
(SELECT id, phone, city, country FROM users WHERE contry = 'Korea')
UNION ALL
(SELECT id, phone, city, country FROM users WHERE contry = 'Mexico')
ORDER BY country;
```
## UNION 정리
컬럼 형식 / 개수 조정이 중요합니다.
중복 제거가 들어가있습니다.
중복 돼도 상관 없으면 UNION ALL 씁니다.
끝.

연습 문제 :
1. orders에서 order_date가 2015년 10월인 건과 2015년 12월인 건을 SELECT로 각각 추출하고, 두 결과 집합을 UNION ALL을 사용해 하나로 결합할 것(단, 최종 결과는 최신 순으로 정렬).
```sql
(SELECT * FROM orders WHERE month = '2015-10' AND order_date < '2015-11-01')
UNION ALL
(SELECT * FROM orders WHERE order_date >= '2015-12-01' AND order_date < '2016-01-01')
ORDER BY order_date DESC;
```
2. users에서 USA에 거주 중이면서 마케팅 수신 동의를 한 회원 정보와 France에서 거주 중이면서 마케팅 수신에 동의하지 않은 회원 정보를 SELECT로 각각 추출하고, 두 결과 집합을 UNION ALL을 사용해 하나로 결합할 것(단, 최종 결과는 id, phone, country, city, is_marketing_agree 컬럼만 출력하고, 거주 국가 기준 알파벳 순으로 정렬할 것).
```sql
(SELECT id, phone, country, city, is_marketing_agree FROM users WHERE country = 'USA' AND is_marketing_agree = 1)
UNION ALL
(SELECT id, phone, country, city, is_marketing_agree FROM users WHERE country = 'France' AND is_marketing_agree = 0)
ORDER BY country ASC;
```
3. UNION을 활용하여 orderdetails와 products를 FULL OUTER JOIN으로 결합하여 출력할 것.(이건 좀 고민해보셔야 합니다. 어떻게 하면 UNION 만으로 FULL OUTER JOIN을 구현할 수 있을지)
- LEFT JOIN + RIGHT JOIN을 수행하면 INNER JOIN 한 번 만큼이 중복됩니다.
- 근데 UNION은 중복 제거 기능이 있습니다.
그럼 (LEFT JOIN) UNION (RIGHT JOIN)을 수행하면 결과적으로 FULL OUTER JOIN이 되겠네요.
- 이걸 SQL로 풀면 됩니다.
```sql
(SELECT * FROM orderdetails od LEFT JOIN products p ON od.product_id = p.id)
UNION
(SELECT * FROM orderdetails od RIGHT JOIN products p ON od.product_id = p.id)
```
그래서 얘는 그냥 FULL OUTER JOIN 쓰면 그만이기 때문에 원리 말고는 가치가 없습니다.

# Sub Query
- SQL의 쿼리 결과를 테이블처럼 사용하는 쿼리 내부의 쿼리.
- 이상의 학습 내용과는 다르게, 기존에는 데이터를 결합할 때 이미 존재하는 테이블에 접근하여 결합을 시도했습니다. 하지만 이제부터는 기존 테이블을 편집하여 만든 결과값을 기준으로 다시 쿼리를 실행하는 형태로 수업이 이루어지게 됩니다.

즉, 개발자가 작성한 쿼리를 실행하여 나온 결과값을 테이블처럼 사용하거나 조건 또는 값으로 사용할 수 있을까? 와 관련된 내용입니다.

서브 쿼리는 SELECT 문 내의 여러 곳에서 사용이 가능한데, 사용하는 위치에 따라 불리는 이름이 다양합니다. 그래서 서브 쿼리 하나로 퉁치면 안되고 어떤 서브쿼리인지 아는게 그 와중에 SQLD에서 시험에 나옵니다.

예제 : products에서 제품명과, 정상 가격을 모두 불러오고, 평균 정상 가격을 새로운 컬럼으로 각 행마다 출력하시오.
```sql
SELECT name, price, (SELECT AVG(price) FROM products) as avgProduct FROM products;
```
`SELECT AVG(price) FROM products;` 의 결과값은 : 전체 price들의 총합을 row 개수만큼 나눈 평균값에 해당할겁니다.

그리고 이상의 SELECT AVG(price) FROM products 쿼리를 실행했을 때는 row = 1 / column = 1인 테이블이 하나 나옵니다.

그리고 이 단일한 결과값이 나온 테이블을 
```sql
SELECT name, price, (SELECT AVG(price) FROM products) as avgProduct FROM products;
```
이렇게 적용시키면 전체 테이블은 name, price, avgProuct로 이루어진 세개의 컬럼을 지닌 테이블이 나오게 될텐데, 서브 쿼리의 결과가 하나의 값만 있기 때문에 모든 row에 SELECT AVG(price) FROM products의 결과값이 붙어서 출력됩니다.

이처럼 _SELECT 절에는 '단일 값을 반환'하는 서브 쿼리가 올 수 있는데_ 이를 `스칼라(Scalar) 서브 쿼리`라고 합니다.

결과 화면의 마지막 컬럼처럼 스칼라 서브 쿼리는 신규 컬럼으로 추가되어 모든 행에 _단일 값을 출력_ 합니다.
```sql
SELECT name, price, 100.00 AS fakePrice
FROM products;

```